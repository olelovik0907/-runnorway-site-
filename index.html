<!doctype html>
<html lang="nb">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>RunNorway</title>
  <meta name="description" content="Løp i Norge – arrangementer og vær">
  <!-- Din eksisterende CSS. Ikke rør denne filen, det er den som gir deg samme look som før. -->
  <link rel="stylesheet" href="/styles.css">
  <!-- Valgfri favicon -->
  <link rel="icon" href="/favicon.ico">
</head>
<body>

  <!-- Din eksisterende header/nav ligger her uendret -->
  <header id="site-header">
    <!-- Behold din markup -->
    <h1 class="site-title">RunNorway</h1>
  </header>

  <main id="content">
    <!-- Dine eksisterende seksjoner beholdes. Følgende containere brukes bare som kroker.
         Du kan ha hva du vil inne i dem; skriptet jobber mot id-er hvis de finnes. -->

    <!-- ARRANGEMENTER: behold din eksisterende liste/kort. -->
    <section id="events-section">
      <!-- Eksempel på din eksisterende struktur. Du kan ha <ul>, <div> eller hva som helst her. -->
      <div id="events-grid">
        <!-- DINE EKSISTERENDE KORT/LISTE. Bildene får fallback automatisk av skriptet. -->
        <!-- Eksempel (kan fjernes): -->
        <article class="event-card" data-event>
          <img class="event-image" src="" alt="Bergen Trail"> <!-- tomt src for å demonstrere fallback -->
          <h3 class="event-title">Bergen Trail</h3>
          <div class="event-meta">
            <span class="event-date">26.04.2025</span>
            <span class="event-city">Bergen</span>
            <span class="event-distance">42.2 km</span>
          </div>
        </article>
      </div>
    </section>

    <!-- VÆR-APP: beholder utseendet ditt. Bare id-ene under trengs for ny funksjon. -->
    <section id="weather-section">
      <div class="weather-widget">
        <div class="weather-controls">
          <input id="weather-search" type="text" placeholder="Søk sted (f.eks. Oslo)" aria-label="Søk etter sted">
          <button id="weather-go">Søk</button>
          <button id="weather-geo">Bruk min posisjon</button>
        </div>
        <div class="weather-current">
          <div id="weather-current-temp">--°C</div>
          <div>
            <div id="weather-current-summary">–</div>
            <small id="weather-current-meta">Vind: – m/s  Nedbør: –%</small>
          </div>
        </div>
        <div id="weather-hours" role="list" aria-label="Neste 12 timer"></div>
      </div>
    </section>
  </main>

  <footer id="site-footer">
    <small>© RunNorway. Mangler et bilde, brukes <code>assets/default-race.jpg</code>.</small>
  </footer>

  <!-- Alt nytt ligger her. Endrer ikke CSS-en din, bare funksjon. -->
  <script>
  // ===============================
  // 1) BILDE-FALLBACK FOR ARRANGEMENTER
  // ===============================
  const DEFAULT_RACE_IMG = "assets/default-race.jpg"; // legg inn denne filen i repoet

  function applyFallbackToImg(img, title) {
    function useDefaultOnce(reason) {
      if (img.dataset.fallbackApplied) return;
      console.warn(reason, title || img.alt || "(uten tittel)");
      img.dataset.fallbackApplied = "1";
      img.src = DEFAULT_RACE_IMG;
    }
    const src = img.getAttribute("src");
    if (!src || !src.trim()) {
      useDefaultOnce("arrangement uten image:");
    }
    img.addEventListener("error", () => useDefaultOnce("bilde mangler/feiler – bruker default for:"));
  }

  function wireEventImageFallback(root = document) {
    // Treffer vanlige mønstre uten å kreve endringer i din markup
    const candidates = root.querySelectorAll(
      'img[data-event-image], img.event-image, .event-card img, [data-event] img, img[alt*="løp" i], img[alt*="race" i]'
    );
    candidates.forEach(img => {
      const card = img.closest("[data-event], .event-card, article, li, div");
      const titleEl = card?.querySelector("[data-title], .event-title, h3, h2, .title");
      const title = titleEl?.textContent?.trim();
      applyFallbackToImg(img, title);
    });
  }

  // Kjør på eksisterende DOM
  wireEventImageFallback();

  // Fanger opp dynamisk innhold som legges til etterpå
  const mo = new MutationObserver(muts => {
    for (const m of muts) {
      m.addedNodes.forEach(n => {
        if (n.nodeType === 1) wireEventImageFallback(n);
      });
    }
  });
  mo.observe(document.body, { childList: true, subtree: true });

  // ===============================
  // 2) VÆR-APP (forbedret, visuelt uendret)
  // ===============================
  const Weather = (() => {
    const pick = (...ids) => ids.map(id => document.getElementById(id)).find(Boolean);

    const el = {
      input: pick("weather-search", "place-input", "vaer-sok"),
      btn: pick("weather-go", "search-btn", "vaer-hent"),
      geo: pick("weather-geo", "geo-btn", "vaer-geo"),
      temp: pick("weather-current-temp", "current-temp", "vaer-temp"),
      summary: pick("weather-current-summary", "current-summary", "vaer-summary"),
      meta: pick("weather-current-meta", "current-meta", "vaer-meta"),
      hours: pick("weather-hours", "hours", "vaer-hours")
    };

    async function geocode(name) {
      const url = new URL("https://geocoding-api.open-meteo.com/v1/search");
      url.searchParams.set("name", name);
      url.searchParams.set("count", "1");
      url.searchParams.set("language", "nb");
      const r = await fetch(url);
      if (!r.ok) throw new Error("Geokoding feilet");
      const j = await r.json();
      if (!j.results?.length) throw new Error("Fant ikke sted");
      const g = j.results[0];
      return { lat: g.latitude, lon: g.longitude, label: `${g.name}${g.admin1 ? ", " + g.admin1 : ""}` };
    }

    async function forecast(lat, lon) {
      const url = new URL("https://api.open-meteo.com/v1/forecast");
      url.searchParams.set("latitude", String(lat));
      url.searchParams.set("longitude", String(lon));
      url.searchParams.set("current_weather", "true");
      url.searchParams.set("hourly", "temperature_2m,precipitation_probability,windspeed_10m,weathercode");
      url.searchParams.set("forecast_days", "2");
      url.searchParams.set("timezone", "auto");
      const r = await fetch(url);
      if (!r.ok) throw new Error("Værkall feilet");
      return r.json();
    }

    function codeToText(code) {
      const map = {
        0:"Klar himmel",1:"For det meste klart",2:"Delvis skyet",3:"Skyet",
        45:"Tåke",48:"Rimet tåke",51:"Lett yr",53:"Yr",55:"Kraftig yr",
        61:"Lett regn",63:"Regn",65:"Kraftig regn",71:"Lett snø",73:"Snø",75:"Kraftig snø",
        80:"Regnbyger",81:"Kraftige regnbyger",82:"Svært kraftige regnbyger",
        95:"Tordenvær",96:"Tordenvær med hagl",99:"Kraftig tordenvær med hagl"
      };
      return map[code] || "Vær";
    }

    function updateUI(data) {
      if (!data) return;

      const c = data.current_weather;
      const h = data.hourly;

      if (el.temp) el.temp.textContent = `${Math.round(c.temperature)}°C`;
      if (el.summary) el.summary.textContent = codeToText(c.weathercode);

      const idx = h.time.findIndex(t => new Date(t).getTime() >= Date.now());
      const i = idx === -1 ? 0 : idx;
      const wind = Math.round(h.windspeed_10m[i]);
      const pp = h.precipitation_probability[i] ?? 0;

      if (el.meta) el.meta.textContent = `Vind: ${wind} m/s  Nedbør: ${pp}%`;

      if (el.hours) {
        el.hours.innerHTML = "";
        for (let k = i; k < Math.min(i + 12, h.time.length); k++) {
          const t = new Date(h.time[k]);
          const cell = document.createElement("div");
          cell.setAttribute("role", "listitem");
          cell.style.display = "inline-block";
          cell.style.marginRight = "8px";
          cell.title = codeToText(h.weathercode[k]);
          cell.innerHTML = `<small>${t.toLocaleTimeString("nb-NO",{hour:"2-digit"})}</small>
                            <div>${Math.round(h.temperature_2m[k])}°</div>
                            <small>${h.precipitation_probability[k] ?? 0}%</small>`;
          el.hours.appendChild(cell);
        }
      }
    }

    async function searchByName(name) {
      const loc = await geocode(name);
      const data = await forecast(loc.lat, loc.lon);
      updateUI(data);
    }

    async function useGeo() {
      if (!navigator.geolocation) {
        alert("Geolokasjon støttes ikke i denne nettleseren");
        return;
      }
      navigator.geolocation.getCurrentPosition(async pos => {
        try {
          const { latitude: lat, longitude: lon } = pos.coords;
          const data = await forecast(lat, lon);
          updateUI(data);
        } catch (e) {
          console.error(e);
          alert("Kunne ikke hente vær for posisjonen");
        }
      }, err => {
        console.warn(err);
        alert("Fikk ikke tilgang til posisjon");
      }, { enableHighAccuracy: true, timeout: 8000 });
    }

    function bindUI() {
      if (el.btn && el.input) {
        el.btn.addEventListener("click", () => {
          const q = el.input.value.trim();
          if (q) searchByName(q).catch(e => { console.error(e); alert("Fant ikke vær for dette stedet"); });
        });
        el.input.addEventListener("keydown", e => {
          if (e.key === "Enter") { e.preventDefault(); el.btn.click(); }
        });
      }
      if (el.geo) el.geo.addEventListener("click", () => useGeo());
    }

    function init() {
      bindUI();
      // valgfritt: last Oslo ved første last
      searchByName("Oslo").catch(() => {});
    }

    return { init };
  })();

  Weather.init();
  </script>
</body>
</html>
